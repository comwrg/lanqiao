# 牛客练习赛16
https://www.nowcoder.com/acm/contest/84

## A (字典序最大的子序列, 贪心)
这题一不小心写成了最长子序列

## B
<pre>
这题一开始想的是假设第一个位置是确定的，然后就可以推出其他位置上的，
然后比较， 然后假设第二个位置是确定的，... 这样， 写到一半写不下去了。。

然后网上看了下别人的解法， 是用基址(这个意思我也不懂咋说， 就暂时叫这个把)做的，
就是说比如 1, 2, 3, 4, 他们的基址都是1, 可以这么算，
1的基址是1-0=1
2的基址是2-1=1
就是他的数值减去他的索引，
这样就可以算出有多少数基址是为1的，
最后只需要取数量最大的那个然后用n减去。

还有题目里面的数是对称的， 所以， 在另一半的基址的算法需要改变一下，
比如 1， 2， 3， 3， 2， 1 这样, 基址应该都是1
后面的索引应该是对称到左边的索引
所以， 右边的索引应该是n-1-right_index
所以， 右边的基址是right_value-(n-1-right_index)
</pre>

## C (并查集)
看了下代码最短的代码， ans--那部分逻辑是错的
```
4
0 1
1 0
1 1
0 0
```
用这个数据就会错误

## D
这题暴力TLE， 找了好久发现有一题跟这题很像LintCode569 <br>
找到了分析 http://blog.51cto.com/13136504/2061163 <br>
wiki: https://en.wikipedia.org/wiki/Digital_root <br>

研究了好久，
主要是用数根的加法还有减法，减法需要考虑特殊情况
具体算法是用遍历sum_dr， 用当前的sum_dr 减去 幸运数 得到了一个数根
然后看这个树根在前面出现过几次， 然后把次数加到ans上就可以了
主要的问题还是考虑特殊情况