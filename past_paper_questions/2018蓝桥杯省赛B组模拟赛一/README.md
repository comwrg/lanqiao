# 2018 蓝桥杯省赛 B 组模拟赛（一）
https://www.jisuanke.com/contest/990

## Question E
这题以前用过dfs写过全排列， 但是没写过去重的全排列。
看了答案之后还不是很懂为什么要这么写， 想了一会加上单步调试终于懂是啥原理了。

比如： *a a b*， 为了方便我标记为 *a1 a2 b* 
全排列有
1. a1 a2 b
2. a1 b  a2
3. a2 a1 b
4. a2 b  a1
5. b  a1 a2
6. b  a2 a1

重复的有1, 3; 2, 4; 5, 6; <br>
分析一下重复于重复之间都有区别。<br>
发现是不是 *a1* 和 *a2* 的顺序不一样
所以我们只需要保留一种顺序的即可。 <br>
为了方便我们就遵循原来的顺序， 就是 *a1 a2 b* 里面 *a1* 和 *a2*的顺序， 
即 *a2* 要在 *a1* 之后， 遵循这条规则就可以保证排列都是不重复的了。

但是代码咋么去写呢？
拿上面第三个排列举例子。<br>
第一次 我们 选了 *a2* <br>
第二次 按照dfs的执行顺序， 我们会从 *a1* 开始选， 但是这个时候是不应该选的。
但是这样可以不选呢？<br>
这个时候可以遍历 *a1* 后面的元素， <br>
先要明确一点
1. 如果后面的元素被选过了， 就说明这个元素是在 *a1* 前面的

所以如果后面的元素等于 *a1* 并且 被选过了， 就说明这种顺序是不遵循原来顺序的。
好像越说越复杂， 简单的说就是<strong>后面相同的元素不能在自己的前面</strong>

# Question G
这题看解析上看不懂， 直接用程序模拟手动计算。 AC 的那一刻突然觉得自己好屌。

# Question H
这题里面的Floyd算法， 一开始觉得蛮简单的， 后来发现暗藏玄机。<br>
一开始我写三重循环写的是 *i, j, k*, 后面发现并不是 *i, j, k*，
而应该是 *k, i, j*， 我开始纳闷了， 这算法不按套路出牌啊。<br>
这使我陷入了深(fa)思(dai)， 我是这么想的， 如果是写 *i, j, k* 这样，
是单独最短路径， 完全没有状态转移， 算一次这路径就定死了，
而 *k, i, j* 是先把所有经过 *k* 点在当前状态下最短路径算出来， 后面再慢慢更新这样。
